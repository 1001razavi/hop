import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
import { Block, BlockTag, BlockWithTransactions, Filter, FilterByBlockHash, Log, TransactionReceipt, TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider';
import { Deferrable } from '@ethersproject/properties';
import { Network } from '@ethersproject/networks';
import { providers } from 'ethers';
export declare class RetryProvider extends providers.StaticJsonRpcProvider implements providers.Provider {
    perform(method: string, params: any): Promise<any>;
    getNetwork: () => Promise<Network>;
    getBlockNumber: () => Promise<number>;
    getGasPrice: () => Promise<BigNumber>;
    getBalance: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<BigNumber>;
    getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<number>;
    getCode: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    getStorageAt: (addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    sendTransaction: (signedTransaction: string | Promise<string>) => Promise<TransactionResponse>;
    call: (transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    estimateGas: (transaction: Deferrable<TransactionRequest>) => Promise<BigNumber>;
    getBlock: (blockHashOrBlockTag: BlockTag | Promise<BlockTag>) => Promise<Block>;
    getBlockWithTransactions: (blockHashOrBlockTag: BlockTag | Promise<BlockTag>) => Promise<BlockWithTransactions>;
    getTransaction: (transactionHash: string | Promise<string>) => Promise<TransactionResponse>;
    getTransactionReceipt: (transactionHash: string | Promise<string>) => Promise<TransactionReceipt>;
    getLogs: (filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>) => Promise<Log[]>;
    resolveName: (name: string | Promise<string>) => Promise<string | null>;
    lookupAddress: (address: string | Promise<string>) => Promise<string | null>;
    getAvatar: (nameOrAddress: string) => Promise<string>;
}
export declare class FallbackProvider implements providers.Provider {
    private _providersFn;
    private _providers;
    private activeIndex;
    _isProvider: boolean;
    constructor(providers: any[]);
    static fromUrls(urls: string[]): FallbackProvider;
    get providers(): any[];
    get connection(): any;
    private getActiveProvider;
    tryProvider(fn: any): Promise<any>;
    getNetwork: () => Promise<Network>;
    getBlockNumber: () => Promise<number>;
    getGasPrice: () => Promise<BigNumber>;
    getBalance: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<BigNumber>;
    getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<number>;
    getCode: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    getStorageAt: (addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    sendTransaction: (signedTransaction: string | Promise<string>) => Promise<TransactionResponse>;
    call: (transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>) => Promise<string>;
    estimateGas: (transaction: Deferrable<TransactionRequest>) => Promise<BigNumber>;
    getBlock: (blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<Block>;
    getBlockWithTransactions: (blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<BlockWithTransactions>;
    getTransaction: (transactionHash: string) => Promise<TransactionResponse>;
    getTransactionReceipt: (transactionHash: string) => Promise<TransactionReceipt>;
    getLogs: (filter: Filter | FilterByBlockHash) => Promise<Log[]>;
    resolveName: (name: string | Promise<string>) => Promise<null | string>;
    lookupAddress: (address: string | Promise<string>) => Promise<null | string>;
    getFeeData(): Promise<any>;
    waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    on(eventName: string, listener: any): any;
    once(eventName: string, listener: any): any;
    emit(eventName: string, ...args: any[]): boolean;
    listenerCount(eventName: string): number;
    listeners(eventName: string): any[];
    off(eventName: string, listener: any): any;
    removeAllListeners(eventName: string): any;
    removeListener(eventName: string, listener: any): any;
    addListener(eventName: string, listener: any): any;
    getAvatar(address: string): Promise<string>;
    detectNetwork(): Promise<Network>;
    getResolver(address: string): Promise<string>;
}
//# sourceMappingURL=Provider.d.ts.map